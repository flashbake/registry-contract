import { MichelsonMap, Schema } from '@taquito/michelson-encoder';
import { bytes2Char, Tzip16ContractAbstraction, MetadataProvider, DEFAULT_HANDLERS } from '@taquito/tzip16';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

var TokenMetadataNotFound = /** @class */ (function () {
    function TokenMetadataNotFound(address) {
        this.address = address;
        this.name = 'TokenMetadataNotFound';
        this.message = "No token metadata was found for the contract: " + address;
    }
    return TokenMetadataNotFound;
}());
var TokenIdNotFound = /** @class */ (function () {
    function TokenIdNotFound(tokenId) {
        this.tokenId = tokenId;
        this.name = 'TokenIdNotFound';
        this.message = "Could not find token metadata for the token ID: " + tokenId;
    }
    return TokenIdNotFound;
}());
var InvalidTokenMetadata = /** @class */ (function () {
    function InvalidTokenMetadata() {
        this.name = 'InvalidTokenMetadata';
        this.message = 'Non-compliance with the TZIP-012 standard. The required property `decimals` is missing.';
    }
    return InvalidTokenMetadata;
}());

var tokenMetadataBigMapType = {
    prim: 'big_map',
    args: [
        { prim: 'nat' },
        { prim: 'pair', args: [
                { prim: 'nat', annots: ['%token_id'] },
                { prim: "map", args: [{ prim: 'string' }, { prim: 'bytes' }], annots: ['%token_info'] }
            ] }
    ],
    annots: ['%token_metadata']
};
var Tzip12ContractAbstraction = /** @class */ (function () {
    function Tzip12ContractAbstraction(contractAbstraction, context) {
        this.contractAbstraction = contractAbstraction;
        this.context = context;
        this._tzip16ContractAbstraction = new Tzip16ContractAbstraction(this.contractAbstraction, this.context);
    }
    /**
     * @description Fetches the contract metadata (according to the Tzip-016 standard)
     * @returns An object containing the metadata, the uri, an optional integrity check result and an optional sha256 hash
     * or `Undefined` if the contract has no metadata (non-compliant with Tzip-016)
     */
    Tzip12ContractAbstraction.prototype.getContractMetadata = function () {
        return __awaiter(this, void 0, void 0, function () {
            var contractMetadata;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this._tzip16ContractAbstraction.getMetadata()];
                    case 1:
                        contractMetadata = _a.sent();
                        return [2 /*return*/, contractMetadata.metadata];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 3];
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @description The Tzip-016 "interfaces" field MUST be present in the contract metadata. It should contain "TZIP-012[version-info]"
     * @returns True if "interfaces" field is present and contains "TZIP-012", false otherwise
     */
    Tzip12ContractAbstraction.prototype.isTzip12Compliant = function () {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var isCompliant, metadata, tzip12Interface;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        isCompliant = false;
                        return [4 /*yield*/, this.getContractMetadata()];
                    case 1:
                        metadata = _b.sent();
                        if (metadata) {
                            tzip12Interface = (_a = metadata.interfaces) === null || _a === void 0 ? void 0 : _a.filter(function (x) {
                                return x.substring(0, 8) === "TZIP-012";
                            });
                            isCompliant = (tzip12Interface && tzip12Interface.length !== 0) ? true : false;
                        }
                        return [2 /*return*/, isCompliant];
                }
            });
        });
    };
    /**
     * @description Fetches the token metadata for a specified token ID.
     * The function first tries to find a `token_metadata` view in the contract metadata and to execute it with the token ID.
     * If there is no view, the function tries to find a `token_metadata` bigmap in the top-level pairs of the storage.
     * @param tokenId The ID of the token for which we want to retrieve token metadata
     * @returns An object of type `TokenMetadata`
     */
    Tzip12ContractAbstraction.prototype.getTokenMetadata = function (tokenId) {
        return __awaiter(this, void 0, void 0, function () {
            var tokenMetadata;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.retrieveTokenMetadataFromView(tokenId)];
                    case 1:
                        tokenMetadata = _a.sent();
                        return [2 /*return*/, (!tokenMetadata) ? this.retrieveTokenMetadataFromBigMap(tokenId) : tokenMetadata];
                }
            });
        });
    };
    Tzip12ContractAbstraction.prototype.retrieveTokenMetadataFromView = function (tokenId) {
        return __awaiter(this, void 0, void 0, function () {
            var views;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getContractMetadata()];
                    case 1:
                        if (!_a.sent()) return [3 /*break*/, 3];
                        return [4 /*yield*/, this._tzip16ContractAbstraction.metadataViews()];
                    case 2:
                        views = _a.sent();
                        if (views && this.hasTokenMetadataView(views)) {
                            return [2 /*return*/, this.executeTokenMetadataView(views['token_metadata'](), tokenId)];
                        }
                        _a.label = 3;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    Tzip12ContractAbstraction.prototype.hasTokenMetadataView = function (views) {
        var e_1, _a;
        try {
            for (var _b = __values(Object.keys(views)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var view = _c.value;
                if (view === 'token_metadata') {
                    return true;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return false;
    };
    Tzip12ContractAbstraction.prototype.executeTokenMetadataView = function (tokenMetadataView, tokenId) {
        return __awaiter(this, void 0, void 0, function () {
            var tokenMetadata, tokenMap, metadataFromUri;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, tokenMetadataView.executeView(tokenId)];
                    case 1:
                        tokenMetadata = _a.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        _a.sent();
                        throw new TokenIdNotFound(tokenId);
                    case 3:
                        tokenMap = Object.values(tokenMetadata)[1];
                        if (!MichelsonMap.isMichelsonMap(tokenMap)) {
                            throw new TokenMetadataNotFound(this.contractAbstraction.address);
                        }
                        return [4 /*yield*/, this.fetchTokenMetadataFromUri(tokenMap)];
                    case 4:
                        metadataFromUri = _a.sent();
                        return [2 /*return*/, this.formatMetadataToken(tokenId, tokenMap, metadataFromUri)];
                }
            });
        });
    };
    Tzip12ContractAbstraction.prototype.fetchTokenMetadataFromUri = function (tokenMetadata) {
        return __awaiter(this, void 0, void 0, function () {
            var uri, metadataFromUri, e_2;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        uri = tokenMetadata.get("");
                        if (!uri) return [3 /*break*/, 4];
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.context.metadataProvider.provideMetadata(this.contractAbstraction, bytes2Char(uri), this.context)];
                    case 2:
                        metadataFromUri = _a.sent();
                        return [2 /*return*/, metadataFromUri.metadata];
                    case 3:
                        e_2 = _a.sent();
                        if (e_2.name === 'InvalidUri') {
                            console.warn("The URI " + bytes2Char(uri) + " is present in the token metadata, but is invalid.");
                        }
                        else {
                            throw e_2;
                        }
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    Tzip12ContractAbstraction.prototype.formatMetadataToken = function (tokenId, metadataTokenMap, metadataFromUri) {
        var e_3, _a, _b, _c, _d;
        var tokenMetadataDecoded = {
            'token_id': tokenId
        };
        try {
            for (var _e = __values(metadataTokenMap.keys()), _f = _e.next(); !_f.done; _f = _e.next()) {
                var keyTokenMetadata = _f.value;
                if (keyTokenMetadata === 'decimals') {
                    Object.assign(tokenMetadataDecoded, (_b = {}, _b[keyTokenMetadata] = Number(bytes2Char(metadataTokenMap.get(keyTokenMetadata))), _b));
                }
                else if (!(keyTokenMetadata === '')) {
                    Object.assign(tokenMetadataDecoded, (_c = {}, _c[keyTokenMetadata] = bytes2Char(metadataTokenMap.get(keyTokenMetadata)), _c));
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_f && !_f.done && (_a = _e.return)) _a.call(_e);
            }
            finally { if (e_3) throw e_3.error; }
        }
        // if an URI is present, add the fetched properties to the object
        // if a property is in the URI and the map, prevalence is accorded to value from the URI
        if (metadataFromUri) {
            for (var property in metadataFromUri) {
                Object.assign(tokenMetadataDecoded, (_d = {}, _d[property] = metadataFromUri[property], _d));
            }
        }
        if (!('decimals' in tokenMetadataDecoded)) {
            throw new InvalidTokenMetadata();
        }
        return tokenMetadataDecoded;
    };
    Tzip12ContractAbstraction.prototype.retrieveTokenMetadataFromBigMap = function (tokenId) {
        return __awaiter(this, void 0, void 0, function () {
            var bigmapTokenMetadataId, pairNatMap, michelsonMap, metadataFromUri;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        bigmapTokenMetadataId = this.findTokenMetadataBigMap();
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.context.contract.getBigMapKeyByID(bigmapTokenMetadataId['int'].toString(), tokenId.toString(), new Schema(tokenMetadataBigMapType))];
                    case 2:
                        pairNatMap = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        _a.sent();
                        throw new TokenIdNotFound(tokenId);
                    case 4:
                        michelsonMap = pairNatMap['token_info'];
                        if (!MichelsonMap.isMichelsonMap(michelsonMap)) {
                            throw new TokenIdNotFound(tokenId);
                        }
                        return [4 /*yield*/, this.fetchTokenMetadataFromUri(michelsonMap)];
                    case 5:
                        metadataFromUri = _a.sent();
                        return [2 /*return*/, this.formatMetadataToken(tokenId, michelsonMap, metadataFromUri)];
                }
            });
        });
    };
    Tzip12ContractAbstraction.prototype.findTokenMetadataBigMap = function () {
        var tokenMetadataBigMapId = this.contractAbstraction.schema.FindFirstInTopLevelPair(this.contractAbstraction.script.storage, tokenMetadataBigMapType);
        if (!tokenMetadataBigMapId) {
            throw new TokenMetadataNotFound(this.contractAbstraction.address);
        }
        return tokenMetadataBigMapId;
    };
    return Tzip12ContractAbstraction;
}());

var ABSTRACTION_KEY = Symbol("Tzip12ContractAbstractionObjectKey");
function tzip12(abs, context) {
    return Object.assign(abs, {
        // namespace tzip12
        tzip12: function () {
            if (!this[ABSTRACTION_KEY]) {
                this[ABSTRACTION_KEY] = new Tzip12ContractAbstraction(this, context);
            }
            return this[ABSTRACTION_KEY];
        }
    });
}

// The same default metadataProvider is used for tzip16 and tzip12
var Tzip12Module = /** @class */ (function () {
    function Tzip12Module(metadataProvider) {
        this._metadataProvider = metadataProvider ? metadataProvider : new MetadataProvider(DEFAULT_HANDLERS);
    }
    Tzip12Module.prototype.configureContext = function (context) {
        Object.assign(context, { metadataProvider: this._metadataProvider });
    };
    return Tzip12Module;
}());

// IMPORTANT: THIS FILE IS AUTO GENERATED! DO NOT MANUALLY EDIT OR CHECKIN!
/* tslint:disable */
var VERSION = {
    "commitHash": "5711569ffaf481d88ba3251343a1788090b35dd4",
    "version": "10.2.1"
};
/* tslint:enable */

export { InvalidTokenMetadata, TokenIdNotFound, TokenMetadataNotFound, Tzip12ContractAbstraction, Tzip12Module, VERSION, tzip12 };
//# sourceMappingURL=taquito-tzip12.es5.js.map
