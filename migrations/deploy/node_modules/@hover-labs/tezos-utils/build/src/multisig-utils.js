"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.callThroughMultisig = exports.simulateOperation = void 0;
const taquito_1 = require("@taquito/taquito");
const rpc_1 = require("@taquito/rpc");
const michel_codec_1 = require("@taquito/michel-codec");
const tezos_multisig_lib_1 = require("@hover-labs/tezos-multisig-lib");
const check_confirmed_1 = __importDefault(require("./check-confirmed"));
async function simulateOperation(tezos, operations, sourceAddress) {
    const header = await tezos.rpc.getBlockHeader();
    const signerPublicKeyHash = await tezos.signer.publicKeyHash();
    const contract = await tezos.rpc.getContract(signerPublicKeyHash);
    const formattedOperations = operations.map((op) => {
        return {
            counter: (parseInt(contract.counter || "0") + 1).toString(),
            destination: op['address'],
            kind: rpc_1.OpKind.TRANSACTION,
            source: sourceAddress || signerPublicKeyHash,
            fee: '0',
            gas_limit: '1040000',
            storage_limit: '60000',
            amount: '0',
            parameters: op.toTransferParams().parameter,
        };
    });
    return await tezos.rpc.runOperation({
        chain_id: header.chain_id,
        operation: {
            branch: header.hash,
            signature: "sigUHx32f9wesZ1n2BWpixXz4AQaZggEtchaQNHYGRCoWNAXx45WGW2ua3apUUUAGMLPwAU41QoaFCzVSL61VaessLg4YbbP",
            contents: formattedOperations,
        },
    });
}
exports.simulateOperation = simulateOperation;
async function callThroughMultisig(config, multiSigContractAddress, targetContract, targetEntrypoint, entrypointArgs, tezos) {
    const michelsonParser = new michel_codec_1.Parser();
    const chainID = await tezos.rpc.getChainId();
    const operationID = await getNextOperationID(tezos, multiSigContractAddress);
    const operationToSign = {
        address: targetContract,
        argSmartPy: entrypointArgs,
        argTypeSmartPy: undefined,
        entrypoint: targetEntrypoint,
        amountMutez: 0,
    };
    const lambdaToSign = (0, tezos_multisig_lib_1.compileOperation)(operationToSign, '~/smartpy-cli/SmartPy.sh');
    const type = michelsonParser.parseMichelineExpression('(pair chain_id (pair nat (lambda unit (list operation))))');
    const encodedData = michelsonParser.parseMichelineExpression(`(Pair "${chainID}" (Pair ${operationID} ${lambdaToSign}))`);
    const packedResult = await tezos.rpc.packData({ data: encodedData, type: type });
    const sig = await tezos.signer.sign(packedResult.packed);
    const multisigContract = await tezos.contract.at(multiSigContractAddress);
    const pkh = await tezos.signer.publicKeyHash();
    const submitCall = multisigContract.methods.submit(taquito_1.MichelsonMap.fromLiteral({
        [pkh]: sig.prefixSig
    }), chainID, operationID, michelsonParser.parseMichelineExpression(lambdaToSign));
    const executeCall = multisigContract.methods.execute(operationID);
    console.log(`Invoking submit()...`);
    const submissionResult = await submitCall.send();
    console.log(`Injected in hash `, submissionResult.hash);
    console.log(`Awaiting confirmation...`);
    await (0, check_confirmed_1.default)(config, submissionResult.hash);
    console.log(`Done!`);
    console.log(`Invoking execute()...`);
    const executeResult = await executeCall.send();
    console.log(`Executed in hash`, executeResult.hash);
    console.log(`Awaiting confirmation...`);
    await (0, check_confirmed_1.default)(config, executeResult.hash);
    console.log(`Done!`);
    return { submissionResult, executeResult };
}
exports.callThroughMultisig = callThroughMultisig;
async function getNextOperationID(tezos, multiSigContractAddress) {
    const multiSigContract = await tezos.contract.at(multiSigContractAddress);
    const multiSigStorage = await multiSigContract.storage();
    const operationId = await multiSigStorage.operationId;
    return operationId.plus(1).toNumber();
}
//# sourceMappingURL=multisig-utils.js.map