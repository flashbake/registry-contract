"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateMetadata = exports.breakGlass = exports.verifyBreakGlassIntegration = exports.verifyDAOIntegrationWithBreakGlass = exports.validateBreakGlass = exports.validateStorageValue = exports.getStorageValue = void 0;
const taquito_1 = require("@taquito/taquito");
const dao_utils_1 = require("./dao-utils");
const multisig_utils_1 = require("./multisig-utils");
const tzip16_1 = require("@taquito/tzip16");
const tzip12_1 = require("@taquito/tzip12");
const getStorageValue = async (targetContract, storageField, tezos) => {
    const contract = await tezos.contract.at(targetContract);
    const storage = await contract.storage();
    const value = storage[storageField];
    if (value === undefined) {
        throw new Error(`No field ${storageField} in ${targetContract}`);
    }
    return value;
};
exports.getStorageValue = getStorageValue;
const validateStorageValue = async (targetContract, storageField, expected, tezos) => {
    const actual = await (0, exports.getStorageValue)(targetContract, storageField, tezos);
    if (valueToString(actual) !== valueToString(expected)) {
        throw new Error(`Error validating ${targetContract}.${storageField}. Actual: ${actual}, Expected: ${expected}`);
    }
};
exports.validateStorageValue = validateStorageValue;
const validateBreakGlass = async (targetContract, targetStorageField, breakGlassContract, breakGlassMsig, dao, tezos) => {
    const targetGovernor = await (0, exports.getStorageValue)(targetContract, targetStorageField, tezos);
    if (targetGovernor !== breakGlassContract) {
        throw new Error(`Governor of ${targetContract} is not set correctly. Actual: ${targetGovernor}, Expected: ${breakGlassContract}`);
    }
    console.log(`       > Governor of target is OK`);
    const actualDao = await (0, exports.getStorageValue)(breakGlassContract, 'daoAddress', tezos);
    if (actualDao !== dao) {
        throw new Error(`DAO is not set correctly for break glass ${breakGlassContract}. Actual: ${actualDao}, Expected: ${dao}`);
    }
    console.log(`       > DAO of break glass is OK`);
    const actualMsig = await (0, exports.getStorageValue)(breakGlassContract, 'multisigAddress', tezos);
    if (actualMsig !== breakGlassMsig) {
        throw new Error(`Msig is not set correctly for break glass ${breakGlassContract}. Actual: ${actualMsig}, Expected: ${breakGlassMsig}`);
    }
    console.log(`       > MSig of break glass is OK`);
    const actualTarget = await (0, exports.getStorageValue)(breakGlassContract, 'targetAddress', tezos);
    if (actualTarget !== targetContract) {
        throw new Error(`Target is not set correctly for target ${breakGlassContract}. Actual: ${actualTarget}, Expected: ${targetContract}`);
    }
    console.log(`       > Target of break glass is OK`);
};
exports.validateBreakGlass = validateBreakGlass;
const verifyDAOIntegrationWithBreakGlass = async (vestingVaultContractAddress, breakGlassContract, targetAddress, entryPoint, entryArguments, entryArgumentType, daoAddress, propertyName, expectedValue, tezos, config) => {
    console.log(`       > Executing governance proposal...`);
    await (0, dao_utils_1.executeGovProposal)(vestingVaultContractAddress, breakGlassContract, targetAddress, entryPoint, entryArguments, entryArgumentType, daoAddress, tezos, config);
    console.log(`       > Proposal finished`);
    await (0, exports.validateStorageValue)(targetAddress, propertyName, expectedValue, tezos);
    console.log(`       > Change Applied`);
};
exports.verifyDAOIntegrationWithBreakGlass = verifyDAOIntegrationWithBreakGlass;
const verifyBreakGlassIntegration = async (breakGlassAddress, targetAddress, multisigAddress, newGovernor, tezos, config) => {
    await (0, exports.breakGlass)(breakGlassAddress, multisigAddress, newGovernor, tezos, config);
    console.log(`       > Glass Broken`);
    (0, exports.validateStorageValue)(targetAddress, 'governorContractAddress', await tezos.signer.publicKeyHash(), tezos);
    console.log(`       > Governor set correctly`);
};
exports.verifyBreakGlassIntegration = verifyBreakGlassIntegration;
const breakGlass = async (breakGlassAddress, multisigAddress, newGovernor, tezos, config) => {
    return await (0, multisig_utils_1.callThroughMultisig)(config, multisigAddress, breakGlassAddress, 'breakGlass', `sp.address("${newGovernor}")`, tezos);
};
exports.breakGlass = breakGlass;
const validateMetadata = async (contractAddress, tezos) => {
    const contract = await tezos.contract.at(contractAddress, (0, taquito_1.compose)(tzip16_1.tzip16, tzip12_1.tzip12));
    const metadata = await contract.tzip16().getMetadata();
    console.log("Parsed Contract Metadata:");
    console.log(`> Name: ${metadata.metadata.name}`);
    console.log(`> Description: ${metadata.metadata.description}`);
    console.log(`> Authors: ${metadata.metadata.authors}`);
    console.log(`> Interfaces: ${metadata.metadata.interfaces}`);
    console.log(`> Homepage: ${metadata.metadata.homepage}`);
    console.log("");
    const tokenMetadata = await contract.tzip12().getTokenMetadata(0);
    console.log("Parsed Contract Metadata:");
    console.log(`> Name: ${tokenMetadata.name}`);
    console.log(`> Symbol: ${tokenMetadata.symbol}`);
    console.log(`> Icon: ${tokenMetadata.icon}`);
    console.log(`> Decimals: ${tokenMetadata.decimals}`);
    console.log(`> Token ID: ${tokenMetadata.token_id}`);
    console.log("");
};
exports.validateMetadata = validateMetadata;
const valueToString = (value) => {
    if (typeof value === 'string') {
        return value;
    }
    if (typeof value === 'boolean') {
        return value ? 'true' : 'false';
    }
    if (typeof value === 'number') {
        return `${value}`;
    }
    if (value === null) {
        return "NULL";
    }
    if (value === undefined) {
        throw new Error(`Values should not be undefined!`);
    }
    if (value.constructor.name === 'BigNumber') {
        return value.toString();
    }
    if (value.constructor.name === 'Date') {
        return `${value.toISOString()}`;
    }
    throw new Error(`Unsupported type ${typeof value}(Class: ${value.constructor.name})`);
};
//# sourceMappingURL=validation-utils.js.map