"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.executeGovProposal = void 0;
const check_confirmed_1 = __importDefault(require("./check-confirmed"));
const michel_codec_1 = require("@taquito/michel-codec");
const utils_1 = require("./utils");
const lambda_utils_1 = require("./lambda-utils");
const executeGovProposal = async (vestingVaultContractAddress, breakGlassContract, targetAddress, entryPoint, entryArguments, entryArgumentType, daoAddress, tezos, config) => {
    const vestingVaultContract = await tezos.contract.at(vestingVaultContractAddress);
    let compiledLambda;
    if (breakGlassContract !== null) {
        console.log(`           - Compiling break glass operation...`);
        compiledLambda = (0, lambda_utils_1.compileBreakGlassOperation)(targetAddress, entryPoint, entryArguments, entryArgumentType, breakGlassContract);
    }
    else {
        throw new Error("Tried to compile a non-break glass lambda!");
    }
    const michelsonParser = new michel_codec_1.Parser();
    const lambdaObject = michelsonParser.parseMichelineExpression(compiledLambda);
    console.log("           - Submitting proposal...");
    const proposalSubmission = tezos.contract.batch([])
        .withContractCall(vestingVaultContract.methods.propose(config.escrowAmount, "Some Title", "http://some.description.link", "some-hash-here", lambdaObject));
    const submissionOp = await proposalSubmission.send();
    await (0, check_confirmed_1.default)(config, submissionOp.hash);
    console.log("           - Proposal injected in", submissionOp.hash);
    console.log("           - Voting yay...");
    const voteOp = await vestingVaultContract.methods.vote(0).send();
    await (0, check_confirmed_1.default)(config, voteOp.hash);
    console.log("           - Vote injected in", voteOp.hash);
    await (0, utils_1.sleep)((config.governanceVoteLength * config.operationDelaySecs) * 1.1);
    console.log("           - Ending vote...");
    const dao = await tezos.contract.at(daoAddress);
    const endVotingOp = await dao.methods.endVoting(null).send();
    await (0, check_confirmed_1.default)(config, endVotingOp.hash);
    console.log("           - endVoting injected in", endVotingOp.hash);
    await (0, utils_1.sleep)((config.governanceTimelockLength * config.operationDelaySecs) * 1.1);
    console.log("           - Executing timelock...");
    const executeTimelockOp = await vestingVaultContract.methods.executeTimelock(null).send();
    console.log("           - Executing timelock injected in", executeTimelockOp.hash);
    await (0, check_confirmed_1.default)(config, executeTimelockOp.hash);
};
exports.executeGovProposal = executeGovProposal;
//# sourceMappingURL=dao-utils.js.map