/** Utilities for validating properties of smart contracts */

import NetworkConfig from './types/network-config'
import { TezosToolkit, compose } from "@taquito/taquito";
import { executeGovProposal } from './dao-utils';
import { callThroughMultisig } from './multisig-utils';
import { Tzip16Module, tzip16 } from '@taquito/tzip16';
import { tzip12 } from '@taquito/tzip12';
import { getTezos } from './taquito-utils';

/** Extract the value from storage at `targetContract.storageField`. Throw if the field is undefined. */
export const getStorageValue = async (targetContract: string, storageField: string, tezos: TezosToolkit) => {
  const contract = await tezos.contract.at(targetContract)
  const storage: any = await contract.storage()
  const value = storage[storageField]

  if (value === undefined) {
    throw new Error(`No field ${storageField} in ${targetContract}`)
  }
  return value
}

/** Validate the value at `targetContract.storageField` matches `expected`. Throw otherwise. */
export const validateStorageValue = async (targetContract: string, storageField: string, expected: any, tezos: TezosToolkit) => {
  const actual = await getStorageValue(targetContract, storageField, tezos)
  if (valueToString(actual) !== valueToString(expected)) {
    throw new Error(`Error validating ${targetContract}.${storageField}. Actual: ${actual}, Expected: ${expected}`)
  }
}

/** 
 * Validate a break glass is wired correctly. Throw otherwise.
 * 
 * @param targetContract The contract managed by the break glass.
 * @param targetStorageField The storage field that contains the governor
 * @param breakGlassContract The break glass contract
 * @param breakGlassMsig The break glass multisig
 * @param dao The DAO
 *  */
export const validateBreakGlass = async (
  targetContract: string,
  targetStorageField: string,
  breakGlassContract: string,
  breakGlassMsig: string,
  dao: string,
  tezos: TezosToolkit
) => {
  // Validate the governor of the target contract is the break glass.
  const targetGovernor = await getStorageValue(targetContract, targetStorageField, tezos)
  if (targetGovernor !== breakGlassContract) {
    throw new Error(`Governor of ${targetContract} is not set correctly. Actual: ${targetGovernor}, Expected: ${breakGlassContract}`)
  }
  console.log(`       > Governor of target is OK`)

  // Validate the break glass is wired to the DAO
  const actualDao = await getStorageValue(breakGlassContract, 'daoAddress', tezos)
  if (actualDao !== dao) {
    throw new Error(`DAO is not set correctly for break glass ${breakGlassContract}. Actual: ${actualDao}, Expected: ${dao}`)
  }
  console.log(`       > DAO of break glass is OK`)

  // Validate the break glass is wired to the Msig
  const actualMsig = await getStorageValue(breakGlassContract, 'multisigAddress', tezos)
  if (actualMsig !== breakGlassMsig) {
    throw new Error(`Msig is not set correctly for break glass ${breakGlassContract}. Actual: ${actualMsig}, Expected: ${breakGlassMsig}`)
  }
  console.log(`       > MSig of break glass is OK`)

  // Validate the break glass is wired to the target
  const actualTarget = await getStorageValue(breakGlassContract, 'targetAddress', tezos)
  if (actualTarget !== targetContract) {
    throw new Error(`Target is not set correctly for target ${breakGlassContract}. Actual: ${actualTarget}, Expected: ${targetContract}`)
  }
  console.log(`       > Target of break glass is OK`)
}

/** 
 * Validate a governance proposal can modify a contract's properties
 * 
 * @param vestingVaultContractAddress Address of the vesting vault which will propose
 * @param breakGlassContract Address of the break glass contract
 * @param targetAddress The target address
 * @param entrypoint The entrypoint to call
 * @param entrypointArguments Argument to the entry point
 * @param entryArgumentType Type of the arguments
 * @param daoAddress Address of the DAO
 * @param propertyName The property name that will change on `targetContract
 * @param expectedValue The expected new value of `targetContract.propertyName`
 * @param tezos Toolkit to manage interaction
 * @param config Network config.
 */
export const verifyDAOIntegrationWithBreakGlass = async (
  vestingVaultContractAddress: string,
  breakGlassContract: string | null,
  targetAddress: string,
  entryPoint: string,
  entryArguments: string,
  entryArgumentType: string,
  daoAddress: string,
  propertyName: string,
  expectedValue: any,
  tezos: TezosToolkit,
  config: NetworkConfig
) => {
  console.log(`       > Executing governance proposal...`)
  await executeGovProposal(
    vestingVaultContractAddress,
    breakGlassContract,
    targetAddress,
    entryPoint,
    entryArguments,
    entryArgumentType,
    daoAddress,
    tezos,
    config
  )
  console.log(`       > Proposal finished`)

  await validateStorageValue(targetAddress, propertyName, expectedValue, tezos)
  console.log(`       > Change Applied`)
}


/**
 * Verify a Break Glass can be broken.
 */
export const verifyBreakGlassIntegration = async (
  breakGlassAddress: string,
  targetAddress: string,
  multisigAddress: string,
  newGovernor: string,
  tezos: TezosToolkit,
  config: NetworkConfig
) => {
  await breakGlass(breakGlassAddress, multisigAddress, newGovernor, tezos, config)
  console.log(`       > Glass Broken`)

  validateStorageValue(targetAddress, 'governorContractAddress', await tezos.signer.publicKeyHash(), tezos)
  console.log(`       > Governor set correctly`)
}

/** Break glass! */
export const breakGlass = async (
  breakGlassAddress: string,
  multisigAddress: string,
  newGovernor: string,
  tezos: TezosToolkit,
  config: NetworkConfig
) => {
  return await callThroughMultisig(
    config,
    multisigAddress,
    breakGlassAddress,
    'breakGlass',
    `sp.address("${newGovernor}")`,
    tezos
  )
}

/**
 * Verify that token metadata is parseable.
 * 
 * Print metadata to the screen to make it obvious.
 */
export const validateMetadata = async (contractAddress: string, tezos: TezosToolkit) => {
  const contract = await tezos.contract.at(contractAddress, compose(tzip16, tzip12))

  const metadata = await contract.tzip16().getMetadata()
  console.log("Parsed Contract Metadata:")
  console.log(`> Name: ${metadata.metadata.name}`)
  console.log(`> Description: ${metadata.metadata.description}`)
  console.log(`> Authors: ${metadata.metadata.authors}`)
  console.log(`> Interfaces: ${metadata.metadata.interfaces}`)
  console.log(`> Homepage: ${metadata.metadata.homepage}`)
  console.log("")

  const tokenMetadata = await contract.tzip12().getTokenMetadata(0)
  console.log("Parsed Contract Metadata:")
  console.log(`> Name: ${tokenMetadata.name}`)
  console.log(`> Symbol: ${tokenMetadata.symbol}`)
  console.log(`> Icon: ${(tokenMetadata as any).icon}`)
  console.log(`> Decimals: ${tokenMetadata.decimals}`)
  console.log(`> Token ID: ${tokenMetadata.token_id}`)

  console.log("")
}

/** Change a value to a string for ease of comparison  */
const valueToString = (value: any): string => {
  // Return the value if it is a string
  if (typeof value === 'string') {
    return value
  }

  // Return for booleans
  if (typeof value === 'boolean') {
    return value ? 'true' : 'false'
  }

  // Return for numbers 
  if (typeof value === 'number') {
    return `${value}`
  }

  // Return 'null' if the value is null. This usually means a value was 'None'
  if (value === null) {
    return "NULL"
  }

  // Throw if the value is undefined - this means Taquito couldn't find a value, not that the value was none.
  if (value === undefined) {
    throw new Error(`Values should not be undefined!`)
  }

  // If we've made it here, then we're likely trying to read an object... 
  // lets try a short list of things we know how to convert

  // Return for BigNumbers
  if (value.constructor.name === 'BigNumber') {
    return value.toString()
  }

  // Return for Date
  if (value.constructor.name === 'Date') {
    return `${value.toISOString()}`
  }

  throw new Error(`Unsupported type ${typeof value}(Class: ${value.constructor.name})`)
}
