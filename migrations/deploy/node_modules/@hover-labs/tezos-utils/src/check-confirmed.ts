/** Make sure an operation is properly confirmed. */

import NetworkConfig from './types/network-config'
import { sleep } from './utils'
const axios = require('axios').default;
import { BigNumber } from 'bignumber.js'

const checkConfirmed = async (config: NetworkConfig, operationHash: string): Promise<void> => {
    // Sleep for the number of blocks to try to get a confirmation without error-ing.
    await sleep((config.requiredConfirmations) * config.operationDelaySecs)

    const operationStatusUrl = `${config.betterCallDevUrl}/opg/${operationHash}`
    const headUrl = `${config.tezosNodeUrl}/chains/main/blocks/head/header`

    for (let currentTry = 0; currentTry < config.maxConfirmationPollingRetries; currentTry++) {
        try {
            // Get operation data
            const operationDataResult = await axios.get(operationStatusUrl)
            if (operationDataResult.status != 200) {
                throw new Error(`Got status code ${operationDataResult.status} when querying operation status`)
            }
            // Note: This API returns an array of operations which might have differing data (ex. gas, storage consumption).
            // Since operation groups are applied atomically and all data we care about (level, status) are the same on an
            // atomic operation, we simply look at the first element.
            const operationData = operationDataResult.data[0]

            // Get explorer head
            const headResult = await axios.get(headUrl)
            if (headResult.status != 200) {
                throw new Error(`Got status code ${headResult.status} when querying operation status.`)
            }
            const headData = headResult.data

            // Operation must be applied.
            if (operationData.status !== 'applied') {
                throw new Error(`Operation is not applied! Current status: ${operationData.status}`)
            }

            // Require the right number of confirmations.
            const headLevel = new BigNumber(headData.level)
            const operationLevel = new BigNumber(operationData.level)
            const delta = headLevel.minus(operationLevel)
            if (delta.isLessThan(config.requiredConfirmations)) {
                throw new Error(`Did not have required number of confirmations. Head: ${headLevel.toFixed()}, Operation: ${operationLevel.toFixed()}`)
            }

            // If we've made it here without an error, then all tests have passed and the operation has confirmed.
            return
        } catch (e) {
            // Something above didn't track - that's probably okay since the network sometimes runs slow.
            // Print the error and sleep for another block before trying again.
            console.log(`Caught exception while polling ${e}`)
            console.log(`(Try ${currentTry + 1} of ${config.maxConfirmationPollingRetries})`)
            await sleep(config.operationDelaySecs)
        }
    }

    // All retries have been exhausted and at this point something is probably borked and we want to crash the program.
    throw new Error(`Could not confirm operation ${operationHash}`)
}

export default checkConfirmed