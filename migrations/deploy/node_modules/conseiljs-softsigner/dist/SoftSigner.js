"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const conseiljs_1 = require("conseiljs");
const CryptoUtils_1 = require("./utils/CryptoUtils");
class SoftSigner {
    constructor(secretKey, isEncrypted = false, salt) {
        this._secretKey = secretKey;
        this._isEncrypted = isEncrypted;
        this._salt = salt ? salt : Buffer.alloc(0);
    }
    getSignerCurve() {
        return conseiljs_1.SignerCurve.ED25519;
    }
    static createSigner(secretKey, password = '') {
        return __awaiter(this, void 0, void 0, function* () {
            if (password.length > 0) {
                const salt = yield CryptoUtils_1.CryptoUtils.generateSaltForPwHash();
                const encryptedKey = yield CryptoUtils_1.CryptoUtils.encryptMessage(secretKey, password, salt);
                return new SoftSigner(encryptedKey, true, salt);
            }
            return new SoftSigner(secretKey);
        });
    }
    getKey(password = '') {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._isEncrypted && password.length > 0) {
                return yield CryptoUtils_1.CryptoUtils.decryptMessage(this._secretKey, password, this._salt);
            }
            return this._secretKey;
        });
    }
    signOperation(bytes, password = '') {
        return __awaiter(this, void 0, void 0, function* () {
            return CryptoUtils_1.CryptoUtils.signDetached(conseiljs_1.TezosMessageUtils.simpleHash(bytes, 32), yield this.getKey(password));
        });
    }
    signText(message, password = '') {
        return __awaiter(this, void 0, void 0, function* () {
            const messageSig = yield CryptoUtils_1.CryptoUtils.signDetached(Buffer.from(message, 'utf8'), yield this.getKey(password));
            return conseiljs_1.TezosMessageUtils.readSignatureWithHint(messageSig, 'edsig');
        });
    }
    signTextHash(message, password = '') {
        return __awaiter(this, void 0, void 0, function* () {
            const messageSig = yield this.signOperation(Buffer.from(message, 'utf8'), password);
            return conseiljs_1.TezosMessageUtils.readSignatureWithHint(messageSig, 'edsig');
        });
    }
}
exports.SoftSigner = SoftSigner;
//# sourceMappingURL=SoftSigner.js.map