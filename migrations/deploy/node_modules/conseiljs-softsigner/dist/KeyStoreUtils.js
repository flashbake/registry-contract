"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const bip39 = __importStar(require("bip39"));
const secp256k1 = __importStar(require("secp256k1"));
const Ed25519 = __importStar(require("ed25519-hd-key"));
const conseiljs_1 = require("conseiljs");
const conseiljs_2 = require("conseiljs");
const CryptoUtils_1 = require("./utils/CryptoUtils");
var KeyStoreUtils;
(function (KeyStoreUtils) {
    function generateMnemonic(strength = 256) {
        return bip39.generateMnemonic(strength);
    }
    KeyStoreUtils.generateMnemonic = generateMnemonic;
    function generateIdentity(strength = 256, password = '', mnemonic) {
        return __awaiter(this, void 0, void 0, function* () {
            return restoreIdentityFromMnemonic((mnemonic || bip39.generateMnemonic(strength)), password);
        });
    }
    KeyStoreUtils.generateIdentity = generateIdentity;
    function restoreIdentityFromSecretKey(secretKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const secretKeyBytes = conseiljs_2.TezosMessageUtils.writeKeyWithHint(secretKey, 'edsk');
            const keys = yield recoverKeys(secretKeyBytes);
            const publicKey = conseiljs_2.TezosMessageUtils.readKeyWithHint(keys.publicKey, 'edpk');
            const publicKeyHash = conseiljs_2.TezosMessageUtils.computeKeyHash(keys.publicKey, 'tz1');
            return { publicKey, secretKey, publicKeyHash, curve: conseiljs_1.KeyStoreCurve.ED25519, storeType: conseiljs_1.KeyStoreType.Mnemonic };
        });
    }
    KeyStoreUtils.restoreIdentityFromSecretKey = restoreIdentityFromSecretKey;
    function restoreIdentityFromMnemonic(mnemonic, password = '', pkh, derivationPath, validate = true) {
        return __awaiter(this, void 0, void 0, function* () {
            if (validate) {
                if (![12, 15, 18, 21, 24].includes(mnemonic.split(' ').length)) {
                    throw new Error('Invalid mnemonic length.');
                }
                if (!bip39.validateMnemonic(mnemonic)) {
                    throw new Error('The given mnemonic could not be validated.');
                }
            }
            let keys;
            const seed = yield bip39.mnemonicToSeed(mnemonic, password);
            if (derivationPath !== undefined && derivationPath.length > 0) {
                const keySource = Ed25519.derivePath(derivationPath, seed.toString("hex"));
                const combinedKey = Buffer.concat([keySource.key, keySource.chainCode]);
                keys = yield recoverKeys(combinedKey);
            }
            else {
                keys = yield generateKeys(seed.slice(0, 32));
            }
            const secretKey = conseiljs_2.TezosMessageUtils.readKeyWithHint(keys.secretKey, 'edsk');
            const publicKey = conseiljs_2.TezosMessageUtils.readKeyWithHint(keys.publicKey, 'edpk');
            const publicKeyHash = conseiljs_2.TezosMessageUtils.computeKeyHash(keys.publicKey, 'tz1');
            if (!!pkh && publicKeyHash !== pkh) {
                throw new Error('The given mnemonic and passphrase do not correspond to the supplied public key hash');
            }
            return { publicKey, secretKey, publicKeyHash, curve: conseiljs_1.KeyStoreCurve.ED25519, storeType: conseiljs_1.KeyStoreType.Mnemonic, seed: mnemonic, derivationPath };
        });
    }
    KeyStoreUtils.restoreIdentityFromMnemonic = restoreIdentityFromMnemonic;
    function restoreIdentityFromFundraiser(mnemonic, email, password, pkh) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield restoreIdentityFromMnemonic(mnemonic, email + password, pkh);
        });
    }
    KeyStoreUtils.restoreIdentityFromFundraiser = restoreIdentityFromFundraiser;
    function generateKeys(seed) {
        return __awaiter(this, void 0, void 0, function* () {
            const keys = yield CryptoUtils_1.CryptoUtils.generateKeys(seed);
            return { publicKey: keys.publicKey, secretKey: keys.secretKey };
        });
    }
    KeyStoreUtils.generateKeys = generateKeys;
    function recoverKeys(secretKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const keys = yield CryptoUtils_1.CryptoUtils.recoverPublicKey(secretKey);
            return { publicKey: keys.publicKey, secretKey: keys.secretKey };
        });
    }
    KeyStoreUtils.recoverKeys = recoverKeys;
    function decryptMessage(message, passphrase, salt) {
        return __awaiter(this, void 0, void 0, function* () {
            return CryptoUtils_1.CryptoUtils.decryptMessage(message, passphrase, salt);
        });
    }
    KeyStoreUtils.decryptMessage = decryptMessage;
    function encryptMessage(message, passphrase, salt) {
        return __awaiter(this, void 0, void 0, function* () {
            return CryptoUtils_1.CryptoUtils.encryptMessage(message, passphrase, salt);
        });
    }
    KeyStoreUtils.encryptMessage = encryptMessage;
    function checkTextSignature(signature, message, publicKey, prehash = false) {
        return __awaiter(this, void 0, void 0, function* () {
            let messageBytes;
            if (prehash) {
                messageBytes = conseiljs_2.TezosMessageUtils.simpleHash(Buffer.from(message, 'utf8'), 32);
            }
            else {
                messageBytes = Buffer.from(message, 'utf8');
            }
            return checkSignature(signature, messageBytes, publicKey);
        });
    }
    KeyStoreUtils.checkTextSignature = checkTextSignature;
    function checkSignature(signature, bytes, publicKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const sigPrefix = signature.slice(0, 5);
            const keyPrefix = publicKey.slice(0, 4);
            let curve = conseiljs_1.SignerCurve.ED25519;
            if (sigPrefix === 'edsig' && keyPrefix === 'edpk') {
                curve = conseiljs_1.SignerCurve.ED25519;
            }
            else if (sigPrefix === 'spsig' && keyPrefix === 'sppk') {
                curve = conseiljs_1.SignerCurve.SECP256K1;
            }
            else if (sigPrefix === 'p2sig' && keyPrefix === 'p2pk') {
                throw new Error('secp256r1 curve is not currently supported');
            }
            else {
                throw new Error(`Signature/key prefix mismatch ${sigPrefix}/${keyPrefix}`);
            }
            const sig = conseiljs_2.TezosMessageUtils.writeSignatureWithHint(signature, sigPrefix);
            const pk = conseiljs_2.TezosMessageUtils.writeKeyWithHint(publicKey, keyPrefix);
            if (curve === conseiljs_1.SignerCurve.ED25519) {
                return yield CryptoUtils_1.CryptoUtils.checkSignature(sig, bytes, pk);
            }
            if (curve === conseiljs_1.SignerCurve.SECP256K1) {
                return secp256k1.ecdsaVerify(sig, bytes, pk);
            }
            return false;
        });
    }
    KeyStoreUtils.checkSignature = checkSignature;
})(KeyStoreUtils = exports.KeyStoreUtils || (exports.KeyStoreUtils = {}));
//# sourceMappingURL=KeyStoreUtils.js.map